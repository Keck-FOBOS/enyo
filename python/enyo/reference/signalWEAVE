#!/usr/bin/env python

# follows Chris Benn's signal.f to compute signal-to-noise or required
# efficiencies for WEAVE

from sys import argv
from numpy import *
import scipy
from scipy.integrate import quad

help="""
Exposure time calculator for WEAVE.  Run as
% ./signalWEAVE <optional switches> <magnitude or surface brightness> <exposure time in seconds>

Switches:
notation: <> represents a number required on input

* Instrumental parameters *
-QE <detector quantum efficiency> [default: 0.9]
-spec <spectrograph efficiency> [default: 0.5]
-fiber <fiber transmission> [default: 0.73]
-PF <prime focus corrector transmission> [default: 0.8]
-eff <overall efficiency> [no default: computed from above parameters]
-diameter <fiber diameter in arcseconds> [default: 1.23]
-resolution <spectral resolution> [default: 5000]
-redArm (return S/N for red arm)
-blueArm [default] (return S/N for blue arm)
-blueLR / -redLR / -blueHR / -redHR (shortcuts for preferred arm/mode)

* Object/observing conditions parameters *
-X <airmass> [default: 1.2]
-sky <surface brightness of sky between the lines> [default: 22.7 mag/sq. arcsec in B band]
-band <band of interest> [default: V] (choices: UBVRI)
-FWHM <full width half maximum of seeing disk> [default: 1.0]
-readnoise <RN in e-> [default: 3]
-dark <dark current in e-/hour> [default: 0.]
-offset <offset of fiber center from object center in arcseconds> [default: 0.]
-sb (switch to set input as surface brightness in mag./sq. arcsec instead of point source magnitudes)

Return values should be self-explanatory!
"""

def rdarg(argv,key,conv=None,default=None,single=0):
   val = default
   if key in argv:
    if not single:
      val=argv[argv.index(key)+1]
      del argv[argv.index(key):argv.index(key)+2]
      if conv: val=map(conv,[val])[0]
    else:
      del argv[argv.index(key):argv.index(key)+1]
      val = 1
      if default == 1: val=0
   else:
      if conv and val: val=apply(conv,(val,))
   return argv,val


class signal:
    def __init__(self,QE=0.9,fiberEff=0.73,specEff=0.5,pfEff=0.8,
                 res=5004.,offset=0.,fiberD=1.23,fFP=3.2,fcol=3.2,fcam=2.,blue=1,
                 red=None):
        # WHT parameters
        self.telarea=12.47
        self.m1Eff=0.85
        # nominal instrumental parameters
        self.QE=QE
        self.fiberEff=fiberEff
        self.specEff=specEff
        self.pfEff=pfEff
        # bands
        self.bands=['U','B','V','R','I','z']
        # central wavelengths for UBVRIz
        self.wave=array([360.,430.,550.,650.,820.,950.],'f')
        # mag -> Jy from Bessell (1979)
        self.fluxJy=array([1810.,4260.,3640.,3080.,2550.,2200.],'f')
        # photons/m^2/s/Ang for m=0
        self.photons=10000*self.fluxJy*1000./(6.6*self.wave)
        # extinction
        self.extinct=array([0.55,0.25,0.15,0.09,0.06,0.05],'f')
        # spectrograph/detector parameters
        self.res=res
        self.fiberD=fiberD
        # pixel size in microns
        self.pixSize=15.
        # fiber diameter in microns
        self.fiberDmu=self.fiberD*fFP*4.2*1e6/206265
        # fiber diameter on CCD in pixels
        self.fiberCCD=self.fiberDmu*(fcam/fcol)/self.pixSize
        # rough dispersion in Angstroms
        if red:
            self.disp=(self.fiberD/1.2278)*(5000./self.res)*10.*(976-604)/8132
        else:
            self.disp=(self.fiberD/1.2278)*(5000./self.res)*10.*(605-374)/8132
        # offset of fiber from object center
        self.offset=offset

    def efficiency(self):
        return self.QE*self.fiberEff*self.specEff*self.pfEff*self.m1Eff

    def effectiveArea(self,eff):
        return eff*self.telarea

    def extinction(self,airmass=1.2):
        return pow(10,-0.4*self.extinct*airmass)

    def lightfrac(self,seeing,fiberD):
        # note that the integral of a circularly-symmetric gaussian over 0 
        # to 2pi and 0 to infinity is just 2 pi sigma^2...
        s=seeing/2.3548
        rfib=fiberD/2.
        lf=quad(lambda x: x*exp(-pow(x-self.offset,2)/(2*s*s))/ \
                (s*(s+self.offset*sqrt(pi/2.))), 0, rfib)[0]
        return lf

    def objectphotons(self,mag,time,band,airmass,effArea):
        return pow(10,-0.4*mag)*time*\
               self.photons.tolist()[self.bands.index(band)]* \
               effArea*self.disp*\
               self.extinction(airmass).tolist()[self.bands.index(band)]

    def skyphotons(self,skysb,time,band,effArea,fiberD):
        return pow(10,-0.4*skysb)*time*\
               self.photons.tolist()[self.bands.index(band)]* \
               pi*pow(fiberD/2.,2)*effArea*self.disp

    def S2N(self,mag,time,band,airmass=1.2,fiberD=1.5,seeing=1.0,rn=3.,dark=0.,\
            eff=None,sb=None,skysb=22.7,skyband="B"):
        # Note: this version returns the S/N per Angstrom!
        npix_spatial=self.fiberCCD
        npix_spectral=1./self.disp
        pixArea=npix_spatial*npix_spectral
        #pixArea=pi*pow(npix/2.,2)
        if not eff:
            eff=self.efficiency()
        effArea=self.effectiveArea(eff)
        if sb:
            ophot=self.objectphotons(mag,time,band,airmass,effArea)*pi*\
                   pow(fiberD/2.,2)
        else:
            ophot=self.objectphotons(mag,time,band,airmass,effArea)*\
                   self.lightfrac(seeing,fiberD)
        sphot=self.skyphotons(skysb,time,skyband,effArea,fiberD)
        SNR=npix_spectral*ophot/sqrt(npix_spectral*ophot+npix_spectral*sphot+pixArea*rn*rn+dark*time/3600.)
##         SNR=ophot/sqrt(ophot+sphot+pixArea*rn*rn+dark*time/3600.)
##         SNR=SNR*sqrt(1./self.disp)
        return {'SNR':SNR,'objectphotons':ophot,'skyphotons':sphot,\
                'efficiency':eff,'effectivearea':effArea,\
                'SNRres':SNR*npix_spatial/npix_spectral}

    def RVaccuracy(self,snr,scale=0.6):
        # scaling taken from Battaglia et al. (2008)
        return scale*pow(10,0.6*pow(log10(snr),2)-2.4*log10(snr)-1.75*log10(self.res)+9.36)

if len(argv)==1:
   print help
   exit()

###################
# Instrumental parameters
###################
# efficiencies: detector, fibers, spectrograph, PFcorr
argv,QE=rdarg(argv,'-QE',float,0.9)
argv,fiberEff=rdarg(argv,'-fiber',float,0.73)
argv,specEff=rdarg(argv,'-spec',float,0.5)
argv,pfEff=rdarg(argv,'-PF',float,0.8)
argv,eff=rdarg(argv,'-eff',float,0.)
if eff==0: eff=None
# fiber diameter
argv,fiberD=rdarg(argv,'-diameter',float,1.2278)
# spectral resolution
argv,res=rdarg(argv,'-resolution',float,5000)
## # rough disperson: Ang/pixel (assumes f/1.75 camera, 15um pixels)
## argv,disp=rdarg(argv,'-disp',float,0.4)
# Fiber injection f/ratio
argv,fFP=rdarg(argv,'-fFocalPlane',float,3.2)
# Collimator f/ratio
argv,fcol=rdarg(argv,'-fCollimator',float,3.2)
# Camera f/ratio
argv,fcam=rdarg(argv,'-fCamera',float,2.)
# Arm
argv,red=rdarg(argv,'-redArm',None,single=1)
argv,blue=rdarg(argv,'-blueArm',default=1,single=1)
if red:
    blue=None
else:
    blue=1
    red=None
# shortcuts
argv,blueLR=rdarg(argv,'-blueLR',default=None,single=1)
argv,redLR=rdarg(argv,'-redLR',default=None,single=1)
argv,blueHR=rdarg(argv,'-blueHR',default=None,single=1)
argv,redHR=rdarg(argv,'-redHR',default=None,single=1)
if blueLR:
   print 'Mode: blueLR'
   res=5000.
   blue=1
   red=None
elif redLR:
   print 'Mode: redLR'
   res=5000.
   blue=None
   red=1
elif blueHR:
   print 'Mode: blueHR'
   res=20000.
   blue=1
   red=None
elif redHR:
   print 'Mode: redHR'
   res=20000.
   blue=None
   red=1

###################
# Object parameters
###################
# airmass
argv,airmass=rdarg(argv,'-X',float,1.2)
# sky brightness *between lines* on dark night, from SIGNAL, assuming roughly
# B-band sky brightness, in mag/sq. arcsec
argv,skysb=rdarg(argv,'-sky',float,22.7)
## # sky flux in photons/s/m^2/Ang/arcsec^2 from Ellis & Bland-Hawthorne (2008)
## # at 900 nm... note that this is ~6.4 x brighter than the above estimate...
## #sky=0.08
# band of interest
argv,band=rdarg(argv,'-band',None,'V')
# seeing FWHM
argv,seeing=rdarg(argv,'-FWHM',float,1.0)
# detector read noise in e-
argv,rn=rdarg(argv,'-readnoise',float,3.)
# dark current/hour
argv,dark=rdarg(argv,'-dark',float,0.)
# offset of fiber from object center
argv,offset=rdarg(argv,'-offset',float,0.)
# surface brightness (otherwise default to point source)?
argv,sb=rdarg(argv,'-sb',None,single=1)

# output radial velocity error?
argv,rv=rdarg(argv,'-rv',single=1)
argv,rvscale=rdarg(argv,'-rvscale',float,0.6)

# magnitude (point source: magnitude; surface brightness: magnitude/sq. arcsec)
mag=float(argv[1])
# exposure time
time=float(argv[2])


S=signal(QE,fiberEff,specEff,pfEff,res,offset,fiberD,fFP,fcol,fcam,blue,red)
snr=S.S2N(mag,time,band,airmass,fiberD,seeing,rn,dark,eff,sb,skysb)
s2n=snr['SNR']

print 'Efficiency = %4.2f effective area = %5.2f m^2' % \
      (snr['efficiency'],snr['effectivearea'])
print 'Object photons = %d sky photons (between lines) = %d' % \
      (snr['objectphotons'],snr['skyphotons'])
print 'S/N/\AA = %8.2f S/N/resolution element = %8.2f' % (s2n,snr['SNRres'])
if rv:
    sigmarv=S.RVaccuracy(s2n,scale=rvscale)
    print 'RV error (km/s) = %8.2f' % (sigmarv)
